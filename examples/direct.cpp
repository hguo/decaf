//---------------------------------------------------------------------------
//
// example of direct coupling
//
// Tom Peterka
// Argonne National Laboratory
// 9700 S. Cass Ave.
// Argonne, IL 60439
// tpeterka@mcs.anl.gov
//
//--------------------------------------------------------------------------
#include <decaf/decaf.hpp>

#include <assert.h>
#include <mpi.h>

// user-defined producer code
void prod_code(void* args)
{
}
// user-defined selector code
void con_code(void* args)
{
}
// user-defined selector code
void sel_type(void *args)
{
}
// user-defined pipeliner code
void pipe_type(void *args)
{
}
// user-defined aggregator code
void aggr_type(void *args)
{
}
// user-defined resilience code
void fault_check(void *args)
{
}
//
// main is the producer (eg. simulation)
//
int main(int argc, char** argv)
{

  MPI_Init(&argc, &argv);

  int err; // decaf error status, 0 is ok

  // create (split) new communicators
  int prod_size = 4;  // fake some communicator sizes: producer
  int con_size = 2;   // consumer
  int dflow_size = 1; // dataflow size defines number of aggregator and other intermediate nodes

  // TODO: need to use pointer instead of automatic variable because otherwise will go
  // out of scope after MPI_Finalize, and the desctructor needs to free the communicator
  decaf::Comm* comm = new decaf::Comm(MPI_COMM_WORLD, prod_size, con_size, dflow_size, err);
  assert(!err);

  // TODO: need to use pointers because their scope spans several conditionals
  decaf::Producer* prod;
  decaf::Consumer* con;
  decaf::Dataflow* dflow;

  // create producer, consumer, dataflow
  if (comm->type() == DECAF_PRODUCER_COMM)
  {
    decaf::Data prod_data;
    prod = new decaf::Producer(*comm,
                         &prod_code,
                         prod_data);
  }
  else if (comm->type() == DECAF_CONSUMER_COMM)
  {
    decaf::Data con_data;
    con = new decaf::Consumer(*comm,
                        &con_code,
                        &sel_type,
                        &pipe_type,
                        &aggr_type,
                        &fault_check,
                        con_data);
  }
  else if (comm->type() == DECAF_DATAFLOW_COMM)
  {
    dflow = new decaf::Dataflow(*comm);
  }

  // simulation loop
  // producer runs multiple time steps and calls the consumer at some interval
  int tot_time_steps = 100; // some fake values
  int con_interval = 10;
  void* data; // pointer to base address of data generated by producer

  for (int t = 0; t < tot_time_steps; t++)
  {
    // custom producer code
    if (comm->type() == DECAF_PRODUCER_COMM)
      prod->exec(data);

    // run the consumer code TODO: only for ranks in consumer comm?
    if (comm->type() == DECAF_CONSUMER_COMM)
    {
      if (!(t % con_interval))
        con->exec(data);
    }
  }

  // cleanup
  // TODO: annoying that I need to delete these instead of letting them go out of scope
  switch(comm->type())
  {
  case DECAF_PRODUCER_COMM:
    delete prod;
    break;
  case DECAF_CONSUMER_COMM:
    delete con;
    break;
  case DECAF_DATAFLOW_COMM:
    delete dflow;
    break;
  default:
    break;
  }
  delete comm;

  MPI_Finalize();
}
