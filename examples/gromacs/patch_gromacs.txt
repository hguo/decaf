From b99a67de86247a6f4a3f22825024cd874cf0e021 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 10:39:56 -0500
Subject: [PATCH 01/21] Patch with dflow and treatment in the simulation code.

---
 CMakeLists.txt                   |  16 ++++
 include/main.h                   |  10 +++
 include/network.h                |   4 +
 include/types/commrec.h          |   4 +
 src/gmxlib/gmx_thread_affinity.c |   6 +-
 src/gmxlib/main.c                |  61 +++++++++++++
 src/gmxlib/network.c             | 182 ++++++++++++++++++++++++++++++++++++++-
 src/kernel/md.c                  |  30 +++++++
 src/kernel/mdrun.c               |  88 ++++++++++++++++++-
 9 files changed, 395 insertions(+), 6 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index bf18a34..3909fd3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1217,6 +1217,22 @@ endif()
 #Simpler to always install.
 install(FILES COPYING DESTINATION ${DATA_INSTALL_DIR} COMPONENT data)
 
+#################
+## Decaf stuff
+################
+if(NOT DECAF_PREFIX)
+  set(DECAF_PREFIX $ENV{DECAF_PREFIX})
+endif()
+
+message(STATUS "MPI PATH : ${MPI_C_INCLUDE_PATH}")
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${DECAF_PREFIX}/cmake)
+find_package(Decaf REQUIRED)
+include_directories(${DECAF_C_INCLUDE_DIR})
+list(APPEND GMX_EXTRA_LIBRARIES ${DECAF_C_DATA_MODEL_LIBRARY} ${DECAF_C_RUNTIME_LIBRARY})
+set (GMX_BINARY_SUFFIX "${GMX_BINARY_SUFFIX}_decaf")
+set (GMX_LIBS_SUFFIX "${GMX_LIBS_SUFFIX}_decaf")
+
 add_subdirectory(share)
 add_subdirectory(include)
 add_subdirectory(src)
diff --git a/include/main.h b/include/main.h
index ed107f6..1a3830f 100644
--- a/include/main.h
+++ b/include/main.h
@@ -43,6 +43,7 @@
 #include <stdio.h>
 #include "visibility.h"
 #include "network.h"
+#include <decaf/C/cdecaf.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -98,6 +99,15 @@ t_commrec *init_par(int *argc, char ***argv_ptr);
  */
 
 GMX_LIBGMX_EXPORT
+t_commrec *init_par_decaf(int *argc, char ***argv_ptr, dca_decaf decaf);
+/* Initiate the parallel computer. Return the communication record
+ * (see network.h). The command line arguments are communicated so that they can be
+ * parsed on each processor.
+ * Arguments are the number of command line arguments, and a pointer to the
+ * array of argument strings. Both are allowed to be NULL.
+ */
+
+GMX_LIBGMX_EXPORT
 t_commrec *init_par_threads(const t_commrec *cro);
 /* Initialize communication records for thread-parallel simulations.
    Must be called on all threads before any communication takes place by
diff --git a/include/network.h b/include/network.h
index 6cfff06..21a1d08 100644
--- a/include/network.h
+++ b/include/network.h
@@ -51,6 +51,7 @@
 #include "typedefs.h"
 #include "main.h"
 #include "gmx_fatal.h"
+#include <decaf/C/cdecaf.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -59,6 +60,9 @@ extern "C" {
 int gmx_setup(int *argc, char **argv, int *nnodes);
 /* Initializes the parallel communication, return the ID of the node */
 
+int gmx_setup_decaf(int *argc, char **argv, int *nnodes, dca_decaf decaf);
+/* Initializes the parallel communication, return the ID of the node */
+
 int gmx_node_num(void);
 /* return the number of nodes in the ring */
 
diff --git a/include/types/commrec.h b/include/types/commrec.h
index 632c52d..19fcb4a 100644
--- a/include/types/commrec.h
+++ b/include/types/commrec.h
@@ -52,6 +52,7 @@ typedef void* MPI_Group;
 #endif
 
 #include "idef.h"
+#include <decaf/C/cdecaf.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -296,6 +297,9 @@ typedef struct {
     /* these buffers are used as destination buffers if MPI_IN_PLACE isn't
        supported.*/
     mpi_in_place_buf_t *mpb;
+
+    dca_decaf decaf;
+
 } t_commrec;
 
 #define MASTERNODE(cr)     (((cr)->nodeid == 0) || !PAR(cr))
diff --git a/src/gmxlib/gmx_thread_affinity.c b/src/gmxlib/gmx_thread_affinity.c
index badb753..1159e6a 100644
--- a/src/gmxlib/gmx_thread_affinity.c
+++ b/src/gmxlib/gmx_thread_affinity.c
@@ -56,6 +56,8 @@
 
 #include "thread_mpi/threads.h"
 
+#include <decaf/C/cdecaf.h>
+
 
 static int
 get_thread_affinity_layout(FILE *fplog,
@@ -236,7 +238,9 @@ gmx_set_thread_affinity(FILE                *fplog,
          */
         MPI_Comm comm_intra;
 
-        MPI_Comm_split(MPI_COMM_WORLD, gmx_hostname_num(), cr->rank_intranode,
+        //MPI_Comm_split(MPI_COMM_WORLD, gmx_hostname_num(), cr->rank_intranode,
+        //               &comm_intra);
+        MPI_Comm_split(dca_get_com(cr->decaf), gmx_hostname_num(), cr->rank_intranode,
                        &comm_intra);
         MPI_Scan(&nthread_local, &thread0_id_node, 1, MPI_INT, MPI_SUM, comm_intra);
         /* MPI_Scan is inclusive, but here we need exclusive */
diff --git a/src/gmxlib/main.c b/src/gmxlib/main.c
index 37c84f7..673f6da 100644
--- a/src/gmxlib/main.c
+++ b/src/gmxlib/main.c
@@ -578,6 +578,67 @@ t_commrec *init_par(int *argc, char ***argv_ptr)
     return cr;
 }
 
+t_commrec *init_par_decaf(int *argc, char ***argv_ptr, dca_decaf decaf)
+{
+    t_commrec    *cr;
+    char        **argv;
+    int           i;
+    gmx_bool      pe = FALSE;
+
+    snew(cr, 1);
+
+    cr->decaf = decaf;
+
+    argv = argv_ptr ? *argv_ptr : NULL;
+
+#if defined GMX_MPI && !defined GMX_THREAD_MPI
+    cr->sim_nodeid = gmx_setup_decaf(argc, argv, &cr->nnodes, decaf);
+
+    if (!PAR(cr) && (cr->sim_nodeid != 0))
+    {
+        gmx_comm("(!PAR(cr) && (cr->sim_nodeid != 0))");
+    }
+
+    cr->mpi_comm_mysim   = dca_get_com(decaf);
+    cr->mpi_comm_mygroup = cr->mpi_comm_mysim;
+#else
+    /* These should never be accessed */
+    cr->mpi_comm_mysim   = NULL;
+    cr->mpi_comm_mygroup = NULL;
+    cr->nnodes           = 1;
+    cr->sim_nodeid       = 0;
+#endif
+
+    cr->nodeid = cr->sim_nodeid;
+
+    cr->duty = (DUTY_PP | DUTY_PME);
+
+    /* Communicate arguments if parallel */
+#ifndef GMX_THREAD_MPI
+    if (PAR(cr))
+    {
+        comm_args(cr, argc, argv_ptr);
+    }
+#endif /* GMX_THREAD_MPI */
+
+#ifdef GMX_MPI
+#if !defined(GMX_THREAD_MPI) && !defined(MPI_IN_PLACE_EXISTS)
+    /* initialize the MPI_IN_PLACE replacement buffers */
+    snew(cr->mpb, 1);
+    cr->mpb->ibuf        = NULL;
+    cr->mpb->libuf       = NULL;
+    cr->mpb->fbuf        = NULL;
+    cr->mpb->dbuf        = NULL;
+    cr->mpb->ibuf_alloc  = 0;
+    cr->mpb->libuf_alloc = 0;
+    cr->mpb->fbuf_alloc  = 0;
+    cr->mpb->dbuf_alloc  = 0;
+#endif
+#endif
+
+    return cr;
+}
+
 t_commrec *init_par_threads(const t_commrec *cro)
 {
 #ifdef GMX_THREAD_MPI
diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 30d4a24..2fcdd44 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -49,6 +49,7 @@
 #include <ctype.h>
 #include "macros.h"
 #include "string2.h"
+#include <decaf/C/cdecaf.h>
 
 #ifdef GMX_LIB_MPI
 #include <mpi.h>
@@ -239,11 +240,177 @@ int gmx_setup(int *argc, char **argv, int *nnodes)
 #endif
 }
 
+
+int gmx_setup_decaf(int *argc, char **argv, int *nnodes, dca_decaf decaf)
+{
+#ifndef GMX_MPI
+    gmx_call("gmx_setup");
+    return 0;
+#else
+    char   buf[256];
+    int    resultlen;             /* actual length of node name      */
+    int    i, flag;
+    int    mpi_num_nodes;
+    int    mpi_my_rank;
+    char   mpi_hostname[MPI_MAX_PROCESSOR_NAME];
+
+    /* Call the MPI routines */
+#ifdef GMX_LIB_MPI
+#ifdef GMX_FAHCORE
+    (void) fah_MPI_Init(argc, &argv);
+#else
+    //(void) MPI_Init(argc, &argv);
+#endif
+#endif
+    (void) MPI_Comm_size( dca_get_com(decaf), &mpi_num_nodes );
+    (void) MPI_Comm_rank( dca_get_com(decaf), &mpi_my_rank );
+    (void) MPI_Get_processor_name( mpi_hostname, &resultlen );
+
+
+#ifdef USE_MPE
+    /* MPE logging routines. Get event IDs from MPE: */
+    /* General events */
+    ev_timestep1               = MPE_Log_get_event_number( );
+    ev_timestep2               = MPE_Log_get_event_number( );
+    ev_force_start             = MPE_Log_get_event_number( );
+    ev_force_finish            = MPE_Log_get_event_number( );
+    ev_do_fnbf_start           = MPE_Log_get_event_number( );
+    ev_do_fnbf_finish          = MPE_Log_get_event_number( );
+    ev_ns_start                = MPE_Log_get_event_number( );
+    ev_ns_finish               = MPE_Log_get_event_number( );
+    ev_calc_bonds_start        = MPE_Log_get_event_number( );
+    ev_calc_bonds_finish       = MPE_Log_get_event_number( );
+    ev_global_stat_start       = MPE_Log_get_event_number( );
+    ev_global_stat_finish      = MPE_Log_get_event_number( );
+    ev_virial_start            = MPE_Log_get_event_number( );
+    ev_virial_finish           = MPE_Log_get_event_number( );
+
+    /* Shift related events */
+    ev_shift_start             = MPE_Log_get_event_number( );
+    ev_shift_finish            = MPE_Log_get_event_number( );
+    ev_unshift_start           = MPE_Log_get_event_number( );
+    ev_unshift_finish          = MPE_Log_get_event_number( );
+    ev_mk_mshift_start         = MPE_Log_get_event_number( );
+    ev_mk_mshift_finish        = MPE_Log_get_event_number( );
+
+    /* PME related events */
+    ev_pme_start                = MPE_Log_get_event_number( );
+    ev_pme_finish               = MPE_Log_get_event_number( );
+    ev_spread_on_grid_start     = MPE_Log_get_event_number( );
+    ev_spread_on_grid_finish    = MPE_Log_get_event_number( );
+    ev_sum_qgrid_start          = MPE_Log_get_event_number( );
+    ev_sum_qgrid_finish         = MPE_Log_get_event_number( );
+    ev_gmxfft3d_start           = MPE_Log_get_event_number( );
+    ev_gmxfft3d_finish          = MPE_Log_get_event_number( );
+    ev_solve_pme_start          = MPE_Log_get_event_number( );
+    ev_solve_pme_finish         = MPE_Log_get_event_number( );
+    ev_gather_f_bsplines_start  = MPE_Log_get_event_number( );
+    ev_gather_f_bsplines_finish = MPE_Log_get_event_number( );
+    ev_reduce_start             = MPE_Log_get_event_number( );
+    ev_reduce_finish            = MPE_Log_get_event_number( );
+    ev_rscatter_start           = MPE_Log_get_event_number( );
+    ev_rscatter_finish          = MPE_Log_get_event_number( );
+    ev_alltoall_start           = MPE_Log_get_event_number( );
+    ev_alltoall_finish          = MPE_Log_get_event_number( );
+    ev_pmeredist_start          = MPE_Log_get_event_number( );
+    ev_pmeredist_finish         = MPE_Log_get_event_number( );
+    ev_init_pme_start           = MPE_Log_get_event_number( );
+    ev_init_pme_finish          = MPE_Log_get_event_number( );
+    ev_send_coordinates_start   = MPE_Log_get_event_number( );
+    ev_send_coordinates_finish  = MPE_Log_get_event_number( );
+    ev_update_fr_start          = MPE_Log_get_event_number( );
+    ev_update_fr_finish         = MPE_Log_get_event_number( );
+    ev_clear_rvecs_start        = MPE_Log_get_event_number( );
+    ev_clear_rvecs_finish       = MPE_Log_get_event_number( );
+    ev_update_start             = MPE_Log_get_event_number( );
+    ev_update_finish            = MPE_Log_get_event_number( );
+    ev_output_start             = MPE_Log_get_event_number( );
+    ev_output_finish            = MPE_Log_get_event_number( );
+    ev_sum_lrforces_start       = MPE_Log_get_event_number( );
+    ev_sum_lrforces_finish      = MPE_Log_get_event_number( );
+    ev_sort_start               = MPE_Log_get_event_number( );
+    ev_sort_finish              = MPE_Log_get_event_number( );
+    ev_sum_qgrid_start          = MPE_Log_get_event_number( );
+    ev_sum_qgrid_finish         = MPE_Log_get_event_number( );
+
+    /* Essential dynamics related events */
+    ev_edsam_start             = MPE_Log_get_event_number( );
+    ev_edsam_finish            = MPE_Log_get_event_number( );
+    ev_get_coords_start        = MPE_Log_get_event_number( );
+    ev_get_coords_finish       = MPE_Log_get_event_number( );
+    ev_ed_apply_cons_start     = MPE_Log_get_event_number( );
+    ev_ed_apply_cons_finish    = MPE_Log_get_event_number( );
+    ev_fit_to_reference_start  = MPE_Log_get_event_number( );
+    ev_fit_to_reference_finish = MPE_Log_get_event_number( );
+
+    /* describe events: */
+    if (mpi_my_rank == 0)
+    {
+        /* General events */
+        MPE_Describe_state(ev_timestep1,               ev_timestep2,                "timestep START",  "magenta" );
+        MPE_Describe_state(ev_force_start,             ev_force_finish,             "force",           "cornflower blue" );
+        MPE_Describe_state(ev_do_fnbf_start,           ev_do_fnbf_finish,           "do_fnbf",         "navy" );
+        MPE_Describe_state(ev_ns_start,                ev_ns_finish,                "neighbor search", "tomato" );
+        MPE_Describe_state(ev_calc_bonds_start,        ev_calc_bonds_finish,        "bonded forces",   "slate blue" );
+        MPE_Describe_state(ev_global_stat_start,       ev_global_stat_finish,       "global stat",     "firebrick3");
+        MPE_Describe_state(ev_update_fr_start,         ev_update_fr_finish,         "update forcerec", "goldenrod");
+        MPE_Describe_state(ev_clear_rvecs_start,       ev_clear_rvecs_finish,       "clear rvecs",     "bisque");
+        MPE_Describe_state(ev_update_start,            ev_update_finish,            "update",          "cornsilk");
+        MPE_Describe_state(ev_output_start,            ev_output_finish,            "output",          "black");
+        MPE_Describe_state(ev_virial_start,            ev_virial_finish,            "calc_virial",     "thistle4");
+
+        /* PME related events */
+        MPE_Describe_state(ev_pme_start,               ev_pme_finish,               "doing PME",       "grey" );
+        MPE_Describe_state(ev_spread_on_grid_start,    ev_spread_on_grid_finish,    "spread",          "dark orange" );
+        MPE_Describe_state(ev_sum_qgrid_start,         ev_sum_qgrid_finish,         "sum qgrid",       "slate blue");
+        MPE_Describe_state(ev_gmxfft3d_start,          ev_gmxfft3d_finish,          "fft3d",           "snow2" );
+        MPE_Describe_state(ev_solve_pme_start,         ev_solve_pme_finish,         "solve PME",       "indian red" );
+        MPE_Describe_state(ev_gather_f_bsplines_start, ev_gather_f_bsplines_finish, "bsplines",        "light sea green" );
+        MPE_Describe_state(ev_reduce_start,            ev_reduce_finish,            "reduce",          "cyan1" );
+        MPE_Describe_state(ev_rscatter_start,          ev_rscatter_finish,          "rscatter",        "cyan3" );
+        MPE_Describe_state(ev_alltoall_start,          ev_alltoall_finish,          "alltoall",        "LightCyan4" );
+        MPE_Describe_state(ev_pmeredist_start,         ev_pmeredist_finish,         "pmeredist",       "thistle" );
+        MPE_Describe_state(ev_init_pme_start,          ev_init_pme_finish,          "init PME",        "snow4");
+        MPE_Describe_state(ev_send_coordinates_start,  ev_send_coordinates_finish,  "send_coordinates", "blue");
+        MPE_Describe_state(ev_sum_lrforces_start,      ev_sum_lrforces_finish,      "sum_LRforces",    "lime green");
+        MPE_Describe_state(ev_sort_start,              ev_sort_finish,              "sort pme atoms",  "brown");
+        MPE_Describe_state(ev_sum_qgrid_start,         ev_sum_qgrid_finish,         "sum charge grid", "medium orchid");
+
+        /* Shift related events */
+        MPE_Describe_state(ev_shift_start,             ev_shift_finish,             "shift",           "orange");
+        MPE_Describe_state(ev_unshift_start,           ev_unshift_finish,           "unshift",         "dark orange");
+        MPE_Describe_state(ev_mk_mshift_start,         ev_mk_mshift_finish,         "mk_mshift",       "maroon");
+
+        /* Essential dynamics related events */
+        MPE_Describe_state(ev_edsam_start,             ev_edsam_finish,             "EDSAM",           "deep sky blue");
+        MPE_Describe_state(ev_get_coords_start,        ev_get_coords_finish,        "ED get coords",   "steel blue");
+        MPE_Describe_state(ev_ed_apply_cons_start,     ev_ed_apply_cons_finish,     "ED apply constr", "forest green");
+        MPE_Describe_state(ev_fit_to_reference_start,  ev_fit_to_reference_finish,  "ED fit to ref",   "lavender");
+
+    }
+    MPE_Init_log();
+#endif
+
+#ifdef GMX_LIB_MPI
+    if (debug)
+    {
+        fprintf(debug, "NNODES=%d, MYRANK=%d, HOSTNAME=%s\n",
+                mpi_num_nodes, mpi_my_rank, mpi_hostname);
+    }
+#endif
+
+    *nnodes = mpi_num_nodes;
+
+    return mpi_my_rank;
+#endif
+}
+
 int  gmx_node_num(void)
 {
 #ifndef GMX_MPI
     return 1;
 #else
+    fprintf(stdout, "Call not ok gmx_node_num\n");
     int i;
     (void) MPI_Comm_size(MPI_COMM_WORLD, &i);
     return i;
@@ -255,6 +422,7 @@ int gmx_node_rank(void)
 #ifndef GMX_MPI
     return 0;
 #else
+    fprintf(stdout, "Call not ok gmx_node_rank\n");
     int i;
     (void) MPI_Comm_rank(MPI_COMM_WORLD, &i);
     return i;
@@ -481,6 +649,7 @@ void gmx_setup_nodecomm(FILE *fplog, t_commrec *cr)
 
 void gmx_init_intranode_counters(t_commrec *cr)
 {
+    fprintf(stdout, "Hello init_intra\n");
     /* counters for PP+PME and PP-only processes on my physical node */
     int nrank_intranode, rank_intranode;
     int nrank_pp_intranode, rank_pp_intranode;
@@ -489,8 +658,10 @@ void gmx_init_intranode_counters(t_commrec *cr)
     int nrank_world, rank_world;
     int i, mynum, *num, *num_s, *num_pp, *num_pp_s;
 
-    MPI_Comm_size(MPI_COMM_WORLD, &nrank_world);
-    MPI_Comm_rank(MPI_COMM_WORLD, &rank_world);
+    //MPI_Comm_size(MPI_COMM_WORLD, &nrank_world);
+    //MPI_Comm_rank(MPI_COMM_WORLD, &rank_world);
+    MPI_Comm_size(dca_get_com( cr->decaf ), &nrank_world);
+    MPI_Comm_rank(dca_get_com( cr->decaf ), &rank_world);
 
     /* Get the node number from the hostname to identify the nodes */
     mynum = gmx_hostname_num();
@@ -504,8 +675,8 @@ void gmx_init_intranode_counters(t_commrec *cr)
     num_s[rank_world]    = mynum;
     num_pp_s[rank_world] = (cr->duty & DUTY_PP) ? mynum : -1;
 
-    MPI_Allreduce(num_s,    num,    nrank_world, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
-    MPI_Allreduce(num_pp_s, num_pp, nrank_world, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+    MPI_Allreduce(num_s,    num,    nrank_world, MPI_INT, MPI_SUM, dca_get_com( cr->decaf ));
+    MPI_Allreduce(num_pp_s, num_pp, nrank_world, MPI_INT, MPI_SUM, dca_get_com( cr->decaf ));
 
     nrank_intranode    = 0;
     rank_intranode     = 0;
@@ -564,6 +735,8 @@ void gmx_init_intranode_counters(t_commrec *cr)
     cr->rank_intranode     = rank_intranode;
     cr->nrank_pp_intranode = nrank_pp_intranode;
     cr->rank_pp_intranode  = rank_pp_intranode;
+
+    fprintf(stdout, "Bye bye init_intra\n");
 }
 
 
@@ -1012,6 +1185,7 @@ void gmx_finalize_par(void)
      * unfinished processes to terminate.
      */
     MPI_Barrier(MPI_COMM_WORLD);
+    //MPI_Barrier(dca_get_com( cr->decaf ));
 
     /*
        if (DOMAINDECOMP(cr)) {
diff --git a/src/kernel/md.c b/src/kernel/md.c
index 4c4a88c..66f8180 100644
--- a/src/kernel/md.c
+++ b/src/kernel/md.c
@@ -104,6 +104,8 @@
 #include "corewrap.h"
 #endif
 
+#include <decaf/C/cdecaf.h>
+
 static void reset_all_counters(FILE *fplog, t_commrec *cr,
                                gmx_large_int_t step,
                                gmx_large_int_t *step_rel, t_inputrec *ir,
@@ -1561,6 +1563,33 @@ double do_md(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[],
             copy_mat(state->svir_prev, shake_vir);
             copy_mat(state->fvir_prev, force_vir);
         }
+
+        //bca_constructdata* in_data = NULL;
+        //unsigned int nb_data = 0;
+        //if((in_data = dca_get(cr->decaf, &nb_data)) == NULL)
+        //{
+        //    gmx_fatal(FARGS, "Could not get data from Decaf");
+        //}
+
+        fprintf(stdout, "Creation of the data model...\n");
+        bca_field field_pos = bca_create_arrayfield(state->x, bca_FLOAT,
+                                                    mdatoms->homenr * 3, 3,
+                                                    mdatoms->homenr * 3, false);
+        bca_constructdata container = bca_create_constructdata();
+
+        if(!bca_append_field(container, "pos",
+                             field_pos, bca_NOFLAG, bca_PRIVATE,
+                             bca_SPLIT_DEFAULT, bca_MERGE_APPEND_VALUES))
+        {
+            gmx_fatal(FARGS, "Could not get append the data field in Decaf");
+        }
+
+        dca_put(cr->decaf, container);
+
+        bca_free_field(field_pos);
+        bca_free_constructdata(container);
+        fprintf(stdout, "Container sent\n");
+
         /*  ################## END TRAJECTORY OUTPUT ################ */
 
         /* Determine the wallclock run time up till now */
@@ -2222,6 +2251,7 @@ double do_md(FILE *fplog, t_commrec *cr, int nfile, const t_filenm fnm[],
         }
 
     }
+
     /* End of main MD loop */
     debug_gmx();
 
diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index eb30fc9..4dbf5ea 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -55,9 +55,42 @@
 #include "thread_mpi.h"
 #endif
 
+#define MAX_STRING_LENGTH 512
+
+#include <decaf/C/cdecaf.h>
+
 /* afm stuf */
 #include "pull.h"
 
+void treatment(dca_decaf decaf)
+{
+    fprintf(stdout, "Launching Treatment\n");
+    bca_constructdata* in_data = NULL;
+    unsigned int nb_data = 0;
+
+    while ((in_data = dca_get(decaf, &nb_data)) != NULL)
+    {
+        fprintf(stdout, "Reception of %u data in treatment\n", nb_data);
+        size_t i;
+        for (i = 0; i < nb_data; i++)
+        {
+            int nb_items = bca_get_nbitems_constructdata(in_data[i]);
+            fprintf(stdout, "Number of particles : %i\n", nb_items);
+            bca_free_constructdata(in_data[i]);
+        }
+        free(in_data);
+    }
+
+    // terminate the task (mandatory) by sending a quit message to the rest of the workflow
+    fprintf(stderr, "Treatment terminating\n");
+    dca_terminate(decaf);
+    MPI_Barrier(MPI_COMM_WORLD);
+    MPI_Finalize();
+    dca_free_decaf(decaf);
+
+    exit(0);
+}
+
 int cmain(int argc, char *argv[])
 {
     const char   *desc[] = {
@@ -577,8 +610,55 @@ int cmain(int argc, char *argv[])
     int           rc;
     char        **multidir = NULL;
 
+    // Preparing Decaf before the initialization of Gromacs structures
+    char * prefix = getenv("DECAF_PREFIX");
+    if(prefix == NULL)
+    {
+        fprintf(stderr, "ERROR: environment variable DECAF_PREFIX not defined. "
+                "Please export DECAF_PREFIX to point to the root of your decaf "
+                "install directory.\n");
+        exit(1);
+    }
 
-    cr = init_par(&argc, &argv);
+    char libpath[MAX_STRING_LENGTH];
+    char path[MAX_STRING_LENGTH];
+    strcpy(libpath, "/examples/C/libmod_dflow_direct.so");
+    strcpy(path, prefix);
+    strcat(path, libpath);
+
+    MPI_Init(&argc, &argv);
+    dca_decaf decaf = dca_create_decaf(MPI_COMM_WORLD);
+    fprintf(stdout,"Creation of Decaf completed\n");
+    int out_link = 0;
+    int in_link = 0;
+    dca_append_workflow_node(decaf, 0, 2, "gmx", 0, NULL, 1, &out_link);
+    dca_append_workflow_node(decaf, 3, 1, "treatment", 1, &in_link, 0, NULL);
+    dca_append_workflow_link(decaf, 0, 1, 2, 1, "dflow",
+                             path, "count", "count");
+
+    fprintf(stdout,"Creation of the workflow completed\n");
+    dca_init_decaf(decaf);
+    if(decaf == NULL)
+        fprintf(stdout, "ERROR : fail to intialize decaf.\n");
+    else
+        fprintf(stdout, "Initialization of Decaf successfull\n");
+
+    if(dca_my_node(decaf, "treatment"))
+        treatment(decaf);
+    else if(dca_my_node(decaf, "gmx"))
+        fprintf(stdout,"Launching gmx\n");
+    else //dflow case
+    {
+        fprintf(stdout, "Cleaning for the dflow\n");
+        MPI_Barrier(MPI_COMM_WORLD);
+        fprintf(stdout, "Barrier passed.\n");
+        dca_terminate(decaf);
+        MPI_Finalize();
+        dca_free_decaf(decaf);
+        exit(0);
+    }
+
+    cr = init_par_decaf(&argc, &argv, decaf);
 
     if (MASTER(cr))
     {
@@ -599,6 +679,8 @@ int cmain(int argc, char *argv[])
        }
      */
 
+
+
     parse_common_args(&argc, argv, PCA_Flags, NFILE, fnm, asize(pa), pa,
                       asize(desc), desc, 0, NULL, &oenv);
 
@@ -761,7 +843,11 @@ int cmain(int argc, char *argv[])
                   nmultisim, repl_ex_nst, repl_ex_nex, repl_ex_seed,
                   pforce, cpt_period, max_hours, deviceOptions, Flags);
 
+    dca_terminate(cr->decaf);
+    fprintf(stdout," Decaf terminated\n");
     gmx_finalize_par();
+    dca_free_decaf(decaf);
+
 
     if (MULTIMASTER(cr))
     {
-- 
2.1.4


From 99ba3e127d18b1dbdac77046daf2e6d46ac2631e Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 13:10:36 -0500
Subject: [PATCH 02/21] Check the status of MPI

---
 CMakeLists.txt | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3909fd3..f3ac23f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1223,7 +1223,11 @@ install(FILES COPYING DESTINATION ${DATA_INSTALL_DIR} COMPONENT data)
 if(NOT DECAF_PREFIX)
   set(DECAF_PREFIX $ENV{DECAF_PREFIX})
 endif()
-
+if(GMX_MPI)
+  message(STATUS "MPI activated.")
+else()
+  message(STATUS "MPI not activated")
+endif()
 message(STATUS "MPI PATH : ${MPI_C_INCLUDE_PATH}")
 
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${DECAF_PREFIX}/cmake)
-- 
2.1.4


From eaa854ab810c29f3e0ecd8c67d7dfbcd3c7602ae Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 13:32:54 -0500
Subject: [PATCH 03/21] Add extra info

---
 CMakeLists.txt | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index f3ac23f..089edd9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1228,6 +1228,11 @@ if(GMX_MPI)
 else()
   message(STATUS "MPI not activated")
 endif()
+if(MPI_FOUND)
+  message(STATUS "MPI trouve.")
+else()
+  message(STATUS "MPI path ot found")
+endif()
 message(STATUS "MPI PATH : ${MPI_C_INCLUDE_PATH}")
 
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${DECAF_PREFIX}/cmake)
-- 
2.1.4


From 634e6e124fc4f4c06f8aab8c10536427f1d56b67 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 14:10:40 -0500
Subject: [PATCH 04/21] Add mpi checks

---
 CMakeLists.txt           | 2 +-
 cmake/gmxManageMPI.cmake | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 089edd9..b2e82d8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1231,7 +1231,7 @@ endif()
 if(MPI_FOUND)
   message(STATUS "MPI trouve.")
 else()
-  message(STATUS "MPI path ot found")
+  message(STATUS "MPI not found")
 endif()
 message(STATUS "MPI PATH : ${MPI_C_INCLUDE_PATH}")
 
diff --git a/cmake/gmxManageMPI.cmake b/cmake/gmxManageMPI.cmake
index 28d23d8..ce4b299 100644
--- a/cmake/gmxManageMPI.cmake
+++ b/cmake/gmxManageMPI.cmake
@@ -49,6 +49,7 @@ if(GMX_MPI)
   # If CMAKE_C_COMPILER is not a MPI wrapper. Try to find MPI using cmake module as fall-back.
   # cmake < 2.8.5 not recommended for fall-back because of unreliability (redmine #851)
   if(NOT MPI_FOUND)
+      message(STATUS "+++++++++++++++++++Trying to find MPI")
       if(CMAKE_VERSION VERSION_LESS "2.8.5")
           set(MPI_PREFIX MPI)
       else()
-- 
2.1.4


From 631fb2aa7e19d3a388ed9956d84e6542651959fc Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 14:16:59 -0500
Subject: [PATCH 05/21] Add mpi checks

---
 cmake/gmxManageMPI.cmake | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/cmake/gmxManageMPI.cmake b/cmake/gmxManageMPI.cmake
index ce4b299..1e3af82 100644
--- a/cmake/gmxManageMPI.cmake
+++ b/cmake/gmxManageMPI.cmake
@@ -35,6 +35,7 @@
 # Manage the MPI setup, assuming that CMAKE_C_COMPILER is an MPI
 # (wrapper) compiler.
 if(GMX_MPI)
+  message(STATUS "+++++++++Starting to look for MPI")
   if(GMX_THREAD_MPI)
     message(STATUS "MPI is not compatible with thread-MPI. Disabling thread-MPI.")
     set(GMX_THREAD_MPI OFF CACHE BOOL
@@ -177,4 +178,6 @@ if(GMX_MPI)
 
   set(GMX_LIB_MPI 1)
   set(PKG_CFLAGS "${PKG_CFLAGS} -DGMX_LIB_MPI")
+else(GMX_MPI)
+ message(STATUS "++++++++++++++ Not trying to find MPI")
 endif(GMX_MPI)
-- 
2.1.4


From d49d34c8c25255bcda600bf22caa185db297a4c9 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 14:33:54 -0500
Subject: [PATCH 06/21] Add infos

---
 CMakeLists.txt | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b2e82d8..b14d7ec 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -485,6 +485,11 @@ option(BUILD_SHARED_LIBS "Enable shared libraries (can be problematic e.g. with
 ########################################################################
 #Process MPI settings
 ########################################################################
+if(GMX_MPI)
+  message(STATUS "++++++++++++++Will check for MPI")
+else(GMX_MPI)
+  message(STATUS "++++++++++++++Won't check for MPI")
+endif(GMX_MPI)
 include(gmxManageMPI)
 
 ########################################################################
-- 
2.1.4


From 2ac35154d1f8bcce44a9ab466404a3ee92b91f12 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 9 Jun 2016 14:37:44 -0500
Subject: [PATCH 07/21] Force MPI

---
 CMakeLists.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b14d7ec..4649e3b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -162,8 +162,8 @@ set(CMAKE_PREFIX_PATH "" CACHE STRING "Extra locations to search for external li
 # User input options                                                   #
 ########################################################################
 option(GMX_DOUBLE "Use double precision (much slower, use only if you really need it)" OFF)
-option(GMX_MPI    "Build a parallel (message-passing) version of GROMACS" OFF)
-option(GMX_THREAD_MPI  "Build a thread-MPI-based multithreaded version of GROMACS (not compatible with MPI)" ON)
+option(GMX_MPI    "Build a parallel (message-passing) version of GROMACS" ON)
+option(GMX_THREAD_MPI  "Build a thread-MPI-based multithreaded version of GROMACS (not compatible with MPI)" OFF)
 option(GMX_SOFTWARE_INVSQRT "Use GROMACS software 1/sqrt" ON)
 mark_as_advanced(GMX_SOFTWARE_INVSQRT)
 option(GMX_FAHCORE "Build a library with mdrun functionality" OFF)
-- 
2.1.4


From 9668b8e9a4fd9f9af762f88b3844b84bf5ac02b0 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 16 Jun 2016 10:53:34 -0500
Subject: [PATCH 08/21] Remove the barrier

---
 include/network.h    |  3 +++
 src/gmxlib/network.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/kernel/mdrun.c   |  4 ++--
 3 files changed, 58 insertions(+), 3 deletions(-)

diff --git a/include/network.h b/include/network.h
index 21a1d08..dab841c 100644
--- a/include/network.h
+++ b/include/network.h
@@ -154,6 +154,9 @@ GMX_LIBGMX_EXPORT
 void gmx_finalize_par(void);
 /* Finish the parallel run in an ordered manner */
 
+GMX_LIBGMX_EXPORT
+void gmx_finalize_par_decaf(dca_decaf decaf);
+
 #ifdef GMX_DOUBLE
 #define gmx_sum_comm  gmx_sumd_comm
 #define gmx_sum       gmx_sumd
diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 2fcdd44..be83348 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -1185,7 +1185,59 @@ void gmx_finalize_par(void)
      * unfinished processes to terminate.
      */
     MPI_Barrier(MPI_COMM_WORLD);
-    //MPI_Barrier(dca_get_com( cr->decaf ));
+
+    /*
+       if (DOMAINDECOMP(cr)) {
+       if (cr->npmenodes > 0 || cr->dd->bCartesian)
+        MPI_Comm_free(&cr->mpi_comm_mygroup);
+       if (cr->dd->bCartesian)
+        MPI_Comm_free(&cr->mpi_comm_mysim);
+       }
+     */
+
+    /* Apparently certain mpich implementations cause problems
+     * with MPI_Finalize. In that case comment out MPI_Finalize.
+     */
+    if (debug)
+    {
+        fprintf(debug, "Will call MPI_Finalize now\n");
+    }
+
+    ret = MPI_Finalize();
+    if (debug)
+    {
+        fprintf(debug, "Return code from MPI_Finalize = %d\n", ret);
+    }
+#endif
+}
+
+void gmx_finalize_par_decaf(dca_decaf decaf)
+{
+#ifndef GMX_MPI
+    /* Compiled without MPI, no MPI finalizing needed */
+    return;
+#else
+    int initialized, finalized;
+    int ret;
+
+    MPI_Initialized(&initialized);
+    if (!initialized)
+    {
+        return;
+    }
+    /* just as a check; we don't want to finalize twice */
+    MPI_Finalized(&finalized);
+    if (finalized)
+    {
+        return;
+    }
+
+    /* We sync the processes here to try to avoid problems
+     * with buggy MPI implementations that could cause
+     * unfinished processes to terminate.
+     */
+    MPI_Barrier(MPI_COMM_WORLD);
+    MPI_Barrier(dca_get_com(decaf));
 
     /*
        if (DOMAINDECOMP(cr)) {
diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 4dbf5ea..38d0acf 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -622,7 +622,7 @@ int cmain(int argc, char *argv[])
 
     char libpath[MAX_STRING_LENGTH];
     char path[MAX_STRING_LENGTH];
-    strcpy(libpath, "/examples/C/libmod_dflow_direct.so");
+    strcpy(libpath, "gromacs/libmod_mod_dflow.so");
     strcpy(path, prefix);
     strcat(path, libpath);
 
@@ -845,7 +845,7 @@ int cmain(int argc, char *argv[])
 
     dca_terminate(cr->decaf);
     fprintf(stdout," Decaf terminated\n");
-    gmx_finalize_par();
+    gmx_finalize_par_decaf(cr->decaf);
     dca_free_decaf(decaf);
 
 
-- 
2.1.4


From 6bb435dbb51329e5179d8fc37fcd3c2c5c9122df Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 16 Jun 2016 11:10:23 -0500
Subject: [PATCH 09/21] Check linkage

---
 src/gmxlib/network.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index be83348..0bded05 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -1236,7 +1236,6 @@ void gmx_finalize_par_decaf(dca_decaf decaf)
      * with buggy MPI implementations that could cause
      * unfinished processes to terminate.
      */
-    MPI_Barrier(MPI_COMM_WORLD);
     MPI_Barrier(dca_get_com(decaf));
 
     /*
-- 
2.1.4


From 076cfedf4249a44a87e65db7cfebc4045b9cb270 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 16 Jun 2016 13:34:04 -0500
Subject: [PATCH 10/21] Attempt to fix crash during finalize

---
 src/gmxlib/network.c | 5 +++--
 src/kernel/mdrun.c   | 2 ++
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 0bded05..cfb951e 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -1250,15 +1250,16 @@ void gmx_finalize_par_decaf(dca_decaf decaf)
     /* Apparently certain mpich implementations cause problems
      * with MPI_Finalize. In that case comment out MPI_Finalize.
      */
-    if (debug)
+    /*if (debug)
     {
         fprintf(debug, "Will call MPI_Finalize now\n");
     }
 
+
     ret = MPI_Finalize();
     if (debug)
     {
         fprintf(debug, "Return code from MPI_Finalize = %d\n", ret);
-    }
+    }*/
 #endif
 }
diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 38d0acf..d0094d9 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -848,6 +848,8 @@ int cmain(int argc, char *argv[])
     gmx_finalize_par_decaf(cr->decaf);
     dca_free_decaf(decaf);
 
+    MPI_Finalize();
+
 
     if (MULTIMASTER(cr))
     {
-- 
2.1.4


From a920a1ed24ab7689c2d6fb5891fb8ea3a32f7bf9 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 13 Jul 2016 13:07:04 -0500
Subject: [PATCH 11/21] Add a Barrier before clearing everything

---
 src/kernel/mdrun.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index d0094d9..7c00299 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -634,7 +634,7 @@ int cmain(int argc, char *argv[])
     dca_append_workflow_node(decaf, 0, 2, "gmx", 0, NULL, 1, &out_link);
     dca_append_workflow_node(decaf, 3, 1, "treatment", 1, &in_link, 0, NULL);
     dca_append_workflow_link(decaf, 0, 1, 2, 1, "dflow",
-                             path, "count", "count");
+                             path, "proc", "count");
 
     fprintf(stdout,"Creation of the workflow completed\n");
     dca_init_decaf(decaf);
@@ -846,6 +846,8 @@ int cmain(int argc, char *argv[])
     dca_terminate(cr->decaf);
     fprintf(stdout," Decaf terminated\n");
     gmx_finalize_par_decaf(cr->decaf);
+
+    MPI_Barrier(MPI_COMM_WORLD);
     dca_free_decaf(decaf);
 
     MPI_Finalize();
-- 
2.1.4


From dbb6d99220e7b293d453ae74fe2c62af0fb43c56 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 13 Jul 2016 13:34:39 -0500
Subject: [PATCH 12/21] Fix the name of the dflow library

---
 src/kernel/mdrun.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 7c00299..7cbe33a 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -622,7 +622,7 @@ int cmain(int argc, char *argv[])
 
     char libpath[MAX_STRING_LENGTH];
     char path[MAX_STRING_LENGTH];
-    strcpy(libpath, "gromacs/libmod_mod_dflow.so");
+    strcpy(libpath, "gromacs/libmod_mod_dflow_gromacs.so");
     strcpy(path, prefix);
     strcat(path, libpath);
 
-- 
2.1.4


From 4fccd84f8007624b8d368838ec4bb269d0247cc8 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 13 Jul 2016 13:39:41 -0500
Subject: [PATCH 13/21] Fix the name of the dflow library

---
 src/kernel/mdrun.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 7cbe33a..e8211a7 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -622,7 +622,7 @@ int cmain(int argc, char *argv[])
 
     char libpath[MAX_STRING_LENGTH];
     char path[MAX_STRING_LENGTH];
-    strcpy(libpath, "gromacs/libmod_mod_dflow_gromacs.so");
+    strcpy(libpath, "/examples/gromacs/libmod_mod_dflow_gromacs.so");
     strcpy(path, prefix);
     strcat(path, libpath);
 
-- 
2.1.4


From 7d667dc746ca675986fae961700bf07271011081 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 13 Jul 2016 13:49:38 -0500
Subject: [PATCH 14/21] Fix the name of the dflow library

---
 src/kernel/mdrun.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index e8211a7..9934ae6 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -622,7 +622,7 @@ int cmain(int argc, char *argv[])
 
     char libpath[MAX_STRING_LENGTH];
     char path[MAX_STRING_LENGTH];
-    strcpy(libpath, "/examples/gromacs/libmod_mod_dflow_gromacs.so");
+    strcpy(libpath, "/examples/gromacs/libmod_dflow_gromacs.so");
     strcpy(path, prefix);
     strcat(path, libpath);
 
-- 
2.1.4


From efca0d61b17dc47a4ebd3b9e440a743da385a330 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 13 Jul 2016 13:56:34 -0500
Subject: [PATCH 15/21] Fix the graph

---
 src/kernel/mdrun.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 9934ae6..4d74f2f 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -631,10 +631,10 @@ int cmain(int argc, char *argv[])
     fprintf(stdout,"Creation of Decaf completed\n");
     int out_link = 0;
     int in_link = 0;
-    dca_append_workflow_node(decaf, 0, 2, "gmx", 0, NULL, 1, &out_link);
-    dca_append_workflow_node(decaf, 3, 1, "treatment", 1, &in_link, 0, NULL);
-    dca_append_workflow_link(decaf, 0, 1, 2, 1, "dflow",
-                             path, "proc", "count");
+    dca_append_workflow_node(decaf, 0, 4, "gmx", 0, NULL, 1, &out_link);
+    dca_append_workflow_node(decaf, 6, 2, "treatment", 1, &in_link, 0, NULL);
+    dca_append_workflow_link(decaf, 0, 1, 4, 2, "dflow",
+                             path, "proc", "block");
 
     fprintf(stdout,"Creation of the workflow completed\n");
     dca_init_decaf(decaf);
-- 
2.1.4


From 12e44804a8cdab3444bd465952262ba3709f810f Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Fri, 22 Jul 2016 15:02:59 -0500
Subject: [PATCH 16/21] Remove the workflow definition from the code and read
 the JSON file instead

---
 src/kernel/mdrun.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 4d74f2f..e206a3c 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -611,7 +611,7 @@ int cmain(int argc, char *argv[])
     char        **multidir = NULL;
 
     // Preparing Decaf before the initialization of Gromacs structures
-    char * prefix = getenv("DECAF_PREFIX");
+    /*char * prefix = getenv("DECAF_PREFIX");
     if(prefix == NULL)
     {
         fprintf(stderr, "ERROR: environment variable DECAF_PREFIX not defined. "
@@ -637,7 +637,8 @@ int cmain(int argc, char *argv[])
                              path, "proc", "block");
 
     fprintf(stdout,"Creation of the workflow completed\n");
-    dca_init_decaf(decaf);
+    dca_init_decaf(decaf);*/
+    dca_init_decaf("/examples/gromacs/wflow_gromacs.json");
     if(decaf == NULL)
         fprintf(stdout, "ERROR : fail to intialize decaf.\n");
     else
-- 
2.1.4


From dd3d5a2bf72a6ea7e8c0bb7d023926b8aab2d507 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Fri, 22 Jul 2016 16:02:13 -0500
Subject: [PATCH 17/21] Typo correction

---
 src/kernel/mdrun.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index e206a3c..c0b9162 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -638,7 +638,7 @@ int cmain(int argc, char *argv[])
 
     fprintf(stdout,"Creation of the workflow completed\n");
     dca_init_decaf(decaf);*/
-    dca_init_decaf("/examples/gromacs/wflow_gromacs.json");
+    dca_init_from_json(decaf, "/examples/gromacs/wflow_gromacs.json");
     if(decaf == NULL)
         fprintf(stdout, "ERROR : fail to intialize decaf.\n");
     else
-- 
2.1.4


From bd9a75dedf3daf776ba81fa75637ae4555f06138 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Fri, 22 Jul 2016 16:07:31 -0500
Subject: [PATCH 18/21] Fix compilation error

---
 src/kernel/mdrun.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index c0b9162..00d7d46 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -611,7 +611,7 @@ int cmain(int argc, char *argv[])
     char        **multidir = NULL;
 
     // Preparing Decaf before the initialization of Gromacs structures
-    /*char * prefix = getenv("DECAF_PREFIX");
+    char * prefix = getenv("DECAF_PREFIX");
     if(prefix == NULL)
     {
         fprintf(stderr, "ERROR: environment variable DECAF_PREFIX not defined. "
@@ -629,7 +629,7 @@ int cmain(int argc, char *argv[])
     MPI_Init(&argc, &argv);
     dca_decaf decaf = dca_create_decaf(MPI_COMM_WORLD);
     fprintf(stdout,"Creation of Decaf completed\n");
-    int out_link = 0;
+    /*int out_link = 0;
     int in_link = 0;
     dca_append_workflow_node(decaf, 0, 4, "gmx", 0, NULL, 1, &out_link);
     dca_append_workflow_node(decaf, 6, 2, "treatment", 1, &in_link, 0, NULL);
-- 
2.1.4


From 8af97b9e4f0ad2771aaf4fada79664822724ad48 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Fri, 22 Jul 2016 16:20:40 -0500
Subject: [PATCH 19/21] Fix Hanging

---
 src/kernel/mdrun.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 00d7d46..09e2e35 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -651,7 +651,7 @@ int cmain(int argc, char *argv[])
     else //dflow case
     {
         fprintf(stdout, "Cleaning for the dflow\n");
-        MPI_Barrier(MPI_COMM_WORLD);
+        //MPI_Barrier(MPI_COMM_WORLD);
         fprintf(stdout, "Barrier passed.\n");
         dca_terminate(decaf);
         MPI_Finalize();
-- 
2.1.4


From 2aeb66c176516bc0af5a77cd346e917bbd2c454b Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 25 Jul 2016 11:09:20 -0500
Subject: [PATCH 20/21] Remove barrier

---
 src/kernel/mdrun.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 09e2e35..5fa5c1f 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -848,7 +848,6 @@ int cmain(int argc, char *argv[])
     fprintf(stdout," Decaf terminated\n");
     gmx_finalize_par_decaf(cr->decaf);
 
-    MPI_Barrier(MPI_COMM_WORLD);
     dca_free_decaf(decaf);
 
     MPI_Finalize();
-- 
2.1.4


From 791728ea9448abd6ea037fffbffce5f99fab1dc1 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 25 Jul 2016 13:36:07 -0500
Subject: [PATCH 21/21] Change json file

---
 src/kernel/mdrun.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 5fa5c1f..74eb7f1 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -638,7 +638,8 @@ int cmain(int argc, char *argv[])
 
     fprintf(stdout,"Creation of the workflow completed\n");
     dca_init_decaf(decaf);*/
-    dca_init_from_json(decaf, "/examples/gromacs/wflow_gromacs.json");
+    //dca_init_from_json(decaf, "/examples/gromacs/wflow_gromacs.json");
+    dca_init_from_json(decaf, "wflow_gromacs.json");
     if(decaf == NULL)
         fprintf(stdout, "ERROR : fail to intialize decaf.\n");
     else
-- 
2.1.4

