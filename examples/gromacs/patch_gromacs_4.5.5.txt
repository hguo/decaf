From a63f12d76fff8c375040d0deccf7080da5417c98 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 25 Aug 2016 17:37:16 -0500
Subject: [PATCH 1/9] Add decaf to Gromacs with steering

---
 CMakeLists.txt          |  25 ++++++
 include/main.h          |   2 +
 include/network.h       |   5 ++
 include/types/commrec.h |  13 ++++
 src/gmxlib/main.c       |  74 ++++++++++++++++++
 src/gmxlib/network.c    | 203 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/kernel/md.c         |  49 ++++++++++++
 src/kernel/mdrun.c      |  61 ++++++++++++++-
 src/mdlib/sim_util.c    | 101 ++++++++++++++++++++++++
 9 files changed, 530 insertions(+), 3 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6c7d3e6..243d3b8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -815,6 +815,31 @@ set(INCL_INSTALL_DIR ${CMAKE_INSTALL_PREFIX}/include)
 
 set(GMXLIBDIR        ${DATA_INSTALL_DIR}/top)
 
+#################
+## Decaf stuff
+################
+if(NOT DECAF_PREFIX)
+  set(DECAF_PREFIX $ENV{DECAF_PREFIX})
+endif()
+if(GMX_MPI)
+  message(STATUS "MPI activated.")
+else()
+  message(STATUS "MPI not activated")
+endif()
+if(MPI_FOUND)
+  message(STATUS "MPI trouve.")
+else()
+  message(STATUS "MPI not found")
+endif()
+message(STATUS "MPI PATH : ${MPI_C_INCLUDE_PATH}")
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${DECAF_PREFIX}/cmake)
+find_package(Decaf REQUIRED)
+include_directories(${DECAF_C_INCLUDE_DIR})
+list(APPEND GMX_EXTRA_LIBRARIES ${DECAF_C_DATA_MODEL_LIBRARY} ${DECAF_C_RUNTIME_LIBRARY})
+set (GMX_BINARY_SUFFIX "${GMX_BINARY_SUFFIX}_4.5.5_decaf")
+set (GMX_LIBS_SUFFIX "${GMX_LIBS_SUFFIX}_4.5.5_decaf")
+
 ##################################################################
 # Shared library settings - Darwin uses INSTALL_NAME_DIR instead!
 ##################################################################
diff --git a/include/main.h b/include/main.h
index ada90d2..ddded05 100644
--- a/include/main.h
+++ b/include/main.h
@@ -88,6 +88,8 @@ t_commrec *init_par(int *argc,char ***argv_ptr);
  * array of argument strings.
  */
 
+t_commrec *init_par_decaf(int *argc,char ***argv_ptr, dca_decaf decaf);
+
 t_commrec *init_par_threads(const t_commrec *cro);
 /* Initialize communication records for thread-parallel simulations. 
    Must be called on all threads before any communication takes place by 
diff --git a/include/network.h b/include/network.h
index 5480c1d..47010ff 100644
--- a/include/network.h
+++ b/include/network.h
@@ -56,6 +56,9 @@ extern "C" {
 int gmx_setup(int *argc,char **argv,int *nnodes);
 /* Initializes the parallel communication, return the ID of the node */
 
+int gmx_setup_decaf(int *argc, char **argv, int *nnodes, dca_decaf decaf);
+/* Initializes the parallel communication, return the ID of the node */
+
 int gmx_node_num(void);
 /* return the number of nodes in the ring */
 
@@ -115,6 +118,8 @@ void gmx_abort(int nodeid,int nnodes,int errorno);
 
 void gmx_finalize(void);
 
+void gmx_finalize_decaf(dca_decaf decaf);
+
 /* Finish the parallel run in an ordered manner */
 
 #ifdef GMX_DOUBLE
diff --git a/include/types/commrec.h b/include/types/commrec.h
index 2baa584..70f15dd 100644
--- a/include/types/commrec.h
+++ b/include/types/commrec.h
@@ -48,6 +48,7 @@ typedef void* MPI_Group;
 #endif
 
 #include "idef.h"
+#include <decaf/C/cdecaf.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -280,6 +281,18 @@ typedef struct {
   /* these buffers are used as destination buffers if MPI_IN_PLACE isn't
      supported.*/
   mpi_in_place_buf_t *mpb;
+
+  dca_decaf decaf;
+
+  int* forceIds;  // Ids of atoms to steer
+  int nbIds;      // Number of atom steered
+  float* force;   // force vector to apply
+  int stepDecaf;  // Do a get/put every stepDecaf iteration
+  bool firstStep; // Marker to signal the first time we call Decaf.
+                  // Needed not to do a get on the first iteration.
+  int iteration;  // simulation step
+  bool terminated;// Received the quit message
+
 } t_commrec;
 
 #define MASTERNODE(cr)     ((cr)->nodeid == 0)
diff --git a/src/gmxlib/main.c b/src/gmxlib/main.c
index 4b335c2..845f562 100644
--- a/src/gmxlib/main.c
+++ b/src/gmxlib/main.c
@@ -587,6 +587,80 @@ t_commrec *init_par(int *argc,char ***argv_ptr)
     return cr;
 }
 
+t_commrec *init_par_decaf(int *argc,char ***argv_ptr, dca_decaf decaf)
+{
+    t_commrec *cr;
+    char      **argv;
+    int       i;
+    gmx_bool      pe=FALSE;
+
+    snew(cr,1);
+
+    cr->decaf = decaf;
+
+    argv = *argv_ptr;
+
+#ifdef GMX_MPI
+#ifdef GMX_LIB_MPI
+    pe = TRUE;
+#ifdef GMX_CHECK_MPI_ENV
+    /* Do not use MPI calls when env.var. GMX_CHECK_MPI_ENV is not set */
+    if (getenv(GMX_CHECK_MPI_ENV) == NULL)
+        pe = FALSE;
+#endif /* GMX_CHECK_MPI_ENV */
+#endif /* GMX_LIB_MPI  */
+    set_parallel_env(pe);
+    if (pe) {
+        cr->sim_nodeid = gmx_setup_decaf(argc,argv,&cr->nnodes, decaf);
+    } else {
+        cr->nnodes     = 1;
+        cr->sim_nodeid = 0;
+    }
+#else /* GMX_MPI */
+    pe=FALSE;
+    set_parallel_env(pe);
+    cr->sim_nodeid   = 0;
+    cr->nnodes       = 1;
+#endif /* GMX_MPI */
+
+    if (!PAR(cr) && (cr->sim_nodeid != 0))
+        gmx_comm("(!PAR(cr) && (cr->sim_nodeid != 0))");
+
+    if (PAR(cr))
+    {
+#ifdef GMX_MPI
+        cr->mpi_comm_mysim = dca_get_com(decaf);
+        cr->mpi_comm_mygroup = cr->mpi_comm_mysim;
+#endif /* GMX_MPI */
+    }
+    cr->nodeid = cr->sim_nodeid;
+
+    cr->duty = (DUTY_PP | DUTY_PME);
+
+    /* Communicate arguments if parallel */
+#ifndef GMX_THREADS
+    if (PAR(cr))
+        comm_args(cr,argc,argv_ptr);
+#endif /* GMX_THREADS */
+
+#ifdef GMX_MPI
+#if !defined(GMX_THREADS) && !defined(MPI_IN_PLACE_EXISTS)
+  /* initialize the MPI_IN_PLACE replacement buffers */
+  snew(cr->mpb, 1);
+  cr->mpb->ibuf=NULL;
+  cr->mpb->libuf=NULL;
+  cr->mpb->fbuf=NULL;
+  cr->mpb->dbuf=NULL;
+  cr->mpb->ibuf_alloc=0;
+  cr->mpb->libuf_alloc=0;
+  cr->mpb->fbuf_alloc=0;
+  cr->mpb->dbuf_alloc=0;
+#endif
+#endif
+
+    return cr;
+}
+
 t_commrec *init_par_threads(const t_commrec *cro)
 {
 #ifdef GMX_THREADS
diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 6933021..252bf44 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -232,11 +232,173 @@ int gmx_setup(int *argc,char **argv,int *nnodes)
 #endif
 }
 
+int gmx_setup_decaf(int *argc,char **argv,int *nnodes, dca_decaf decaf)
+{
+#ifndef GMX_MPI
+  gmx_call("gmx_setup");
+  return 0;
+#else
+  char   buf[256];
+  int    resultlen;               /* actual length of node name      */
+  int    i,flag;
+  int  mpi_num_nodes;
+  int  mpi_my_rank;
+  char mpi_hostname[MPI_MAX_PROCESSOR_NAME];
+
+  /* Call the MPI routines */
+#ifdef GMX_LIB_MPI
+#ifdef GMX_FAHCORE
+  (void) fah_MPI_Init(argc,&argv);
+#else
+  (void) MPI_Init(argc,&argv);
+#endif
+#endif
+  (void) MPI_Comm_size( dca_get_com(decaf), &mpi_num_nodes );
+  (void) MPI_Comm_rank( dca_get_com(decaf), &mpi_my_rank );
+  (void) MPI_Get_processor_name( mpi_hostname, &resultlen );
+
+
+#ifdef USE_MPE
+  /* MPE logging routines. Get event IDs from MPE: */
+  /* General events */
+  ev_timestep1               = MPE_Log_get_event_number( );
+  ev_timestep2               = MPE_Log_get_event_number( );
+  ev_force_start             = MPE_Log_get_event_number( );
+  ev_force_finish            = MPE_Log_get_event_number( );
+  ev_do_fnbf_start           = MPE_Log_get_event_number( );
+  ev_do_fnbf_finish          = MPE_Log_get_event_number( );
+  ev_ns_start                = MPE_Log_get_event_number( );
+  ev_ns_finish               = MPE_Log_get_event_number( );
+  ev_calc_bonds_start        = MPE_Log_get_event_number( );
+  ev_calc_bonds_finish       = MPE_Log_get_event_number( );
+  ev_global_stat_start       = MPE_Log_get_event_number( );
+  ev_global_stat_finish      = MPE_Log_get_event_number( );
+  ev_virial_start            = MPE_Log_get_event_number( );
+  ev_virial_finish           = MPE_Log_get_event_number( );
+
+  /* Shift related events */
+  ev_shift_start             = MPE_Log_get_event_number( );
+  ev_shift_finish            = MPE_Log_get_event_number( );
+  ev_unshift_start           = MPE_Log_get_event_number( );
+  ev_unshift_finish          = MPE_Log_get_event_number( );
+  ev_mk_mshift_start         = MPE_Log_get_event_number( );
+  ev_mk_mshift_finish        = MPE_Log_get_event_number( );
+
+  /* PME related events */
+  ev_pme_start               = MPE_Log_get_event_number( );
+  ev_pme_finish              = MPE_Log_get_event_number( );
+  ev_spread_on_grid_start    = MPE_Log_get_event_number( );
+  ev_spread_on_grid_finish   = MPE_Log_get_event_number( );
+  ev_sum_qgrid_start         = MPE_Log_get_event_number( );
+  ev_sum_qgrid_finish        = MPE_Log_get_event_number( );
+  ev_gmxfft3d_start          = MPE_Log_get_event_number( );
+  ev_gmxfft3d_finish         = MPE_Log_get_event_number( );
+  ev_solve_pme_start         = MPE_Log_get_event_number( );
+  ev_solve_pme_finish        = MPE_Log_get_event_number( );
+  ev_gather_f_bsplines_start = MPE_Log_get_event_number( );
+  ev_gather_f_bsplines_finish= MPE_Log_get_event_number( );
+  ev_reduce_start            = MPE_Log_get_event_number( );
+  ev_reduce_finish           = MPE_Log_get_event_number( );
+  ev_rscatter_start          = MPE_Log_get_event_number( );
+  ev_rscatter_finish         = MPE_Log_get_event_number( );
+  ev_alltoall_start          = MPE_Log_get_event_number( );
+  ev_alltoall_finish         = MPE_Log_get_event_number( );
+  ev_pmeredist_start         = MPE_Log_get_event_number( );
+  ev_pmeredist_finish        = MPE_Log_get_event_number( );
+  ev_init_pme_start          = MPE_Log_get_event_number( );
+  ev_init_pme_finish         = MPE_Log_get_event_number( );
+  ev_send_coordinates_start  = MPE_Log_get_event_number( );
+  ev_send_coordinates_finish = MPE_Log_get_event_number( );
+  ev_update_fr_start         = MPE_Log_get_event_number( );
+  ev_update_fr_finish        = MPE_Log_get_event_number( );
+  ev_clear_rvecs_start       = MPE_Log_get_event_number( );
+  ev_clear_rvecs_finish      = MPE_Log_get_event_number( );
+  ev_update_start            = MPE_Log_get_event_number( );
+  ev_update_finish           = MPE_Log_get_event_number( );
+  ev_output_start            = MPE_Log_get_event_number( );
+  ev_output_finish           = MPE_Log_get_event_number( );
+  ev_sum_lrforces_start      = MPE_Log_get_event_number( );
+  ev_sum_lrforces_finish     = MPE_Log_get_event_number( );
+  ev_sort_start              = MPE_Log_get_event_number( );
+  ev_sort_finish             = MPE_Log_get_event_number( );
+  ev_sum_qgrid_start         = MPE_Log_get_event_number( );
+  ev_sum_qgrid_finish        = MPE_Log_get_event_number( );
+
+  /* Essential dynamics related events */
+  ev_edsam_start             = MPE_Log_get_event_number( );
+  ev_edsam_finish            = MPE_Log_get_event_number( );
+  ev_get_coords_start        = MPE_Log_get_event_number( );
+  ev_get_coords_finish       = MPE_Log_get_event_number( );
+  ev_ed_apply_cons_start     = MPE_Log_get_event_number( );
+  ev_ed_apply_cons_finish    = MPE_Log_get_event_number( );
+  ev_fit_to_reference_start  = MPE_Log_get_event_number( );
+  ev_fit_to_reference_finish = MPE_Log_get_event_number( );
+
+  /* describe events: */
+  if ( mpi_my_rank == 0 )
+  {
+    /* General events */
+    MPE_Describe_state(ev_timestep1,               ev_timestep2,                "timestep START",  "magenta" );
+    MPE_Describe_state(ev_force_start,             ev_force_finish,             "force",           "cornflower blue" );
+    MPE_Describe_state(ev_do_fnbf_start,           ev_do_fnbf_finish,           "do_fnbf",         "navy" );
+    MPE_Describe_state(ev_ns_start,                ev_ns_finish,                "neighbor search", "tomato" );
+    MPE_Describe_state(ev_calc_bonds_start,        ev_calc_bonds_finish,        "bonded forces",   "slate blue" );
+    MPE_Describe_state(ev_global_stat_start,       ev_global_stat_finish,       "global stat",     "firebrick3");
+    MPE_Describe_state(ev_update_fr_start,         ev_update_fr_finish,         "update forcerec", "goldenrod");
+    MPE_Describe_state(ev_clear_rvecs_start,       ev_clear_rvecs_finish,       "clear rvecs",     "bisque");
+    MPE_Describe_state(ev_update_start,            ev_update_finish,            "update",          "cornsilk");
+    MPE_Describe_state(ev_output_start,            ev_output_finish,            "output",          "black");
+    MPE_Describe_state(ev_virial_start,            ev_virial_finish,            "calc_virial",     "thistle4");
+
+    /* PME related events */
+    MPE_Describe_state(ev_pme_start,               ev_pme_finish,               "doing PME",       "grey" );
+    MPE_Describe_state(ev_spread_on_grid_start,    ev_spread_on_grid_finish,    "spread",          "dark orange" );
+    MPE_Describe_state(ev_sum_qgrid_start,         ev_sum_qgrid_finish,         "sum qgrid",       "slate blue");
+    MPE_Describe_state(ev_gmxfft3d_start,          ev_gmxfft3d_finish,          "fft3d",           "snow2" );
+    MPE_Describe_state(ev_solve_pme_start,         ev_solve_pme_finish,         "solve PME",       "indian red" );
+    MPE_Describe_state(ev_gather_f_bsplines_start, ev_gather_f_bsplines_finish, "bsplines",        "light sea green" );
+    MPE_Describe_state(ev_reduce_start,            ev_reduce_finish,            "reduce",          "cyan1" );
+    MPE_Describe_state(ev_rscatter_start,          ev_rscatter_finish,          "rscatter",        "cyan3" );
+    MPE_Describe_state(ev_alltoall_start,          ev_alltoall_finish,          "alltoall",        "LightCyan4" );
+    MPE_Describe_state(ev_pmeredist_start,         ev_pmeredist_finish,         "pmeredist",       "thistle" );
+    MPE_Describe_state(ev_init_pme_start,          ev_init_pme_finish,          "init PME",        "snow4");
+    MPE_Describe_state(ev_send_coordinates_start,  ev_send_coordinates_finish,  "send_coordinates","blue");
+    MPE_Describe_state(ev_sum_lrforces_start,      ev_sum_lrforces_finish,      "sum_LRforces",    "lime green");
+    MPE_Describe_state(ev_sort_start,              ev_sort_finish,              "sort pme atoms",  "brown");
+    MPE_Describe_state(ev_sum_qgrid_start,         ev_sum_qgrid_finish,         "sum charge grid", "medium orchid");
+
+    /* Shift related events */
+    MPE_Describe_state(ev_shift_start,             ev_shift_finish,             "shift",           "orange");
+    MPE_Describe_state(ev_unshift_start,           ev_unshift_finish,           "unshift",         "dark orange");
+    MPE_Describe_state(ev_mk_mshift_start,         ev_mk_mshift_finish,         "mk_mshift",       "maroon");
+
+    /* Essential dynamics related events */
+    MPE_Describe_state(ev_edsam_start,             ev_edsam_finish,             "EDSAM",           "deep sky blue");
+    MPE_Describe_state(ev_get_coords_start,        ev_get_coords_finish,        "ED get coords",   "steel blue");
+    MPE_Describe_state(ev_ed_apply_cons_start,     ev_ed_apply_cons_finish,     "ED apply constr", "forest green");
+    MPE_Describe_state(ev_fit_to_reference_start,  ev_fit_to_reference_finish,  "ED fit to ref",   "lavender");
+
+  }
+  MPE_Init_log();
+#endif
+
+#ifdef GMX_LIB_MPI
+  fprintf(stderr,"NNODES=%d, MYRANK=%d, HOSTNAME=%s\n",
+          mpi_num_nodes,mpi_my_rank,mpi_hostname);
+#endif
+
+  *nnodes=mpi_num_nodes;
+
+  return mpi_my_rank;
+#endif
+}
+
 int  gmx_node_num(void)
 {
 #ifndef GMX_MPI
   return 1;
 #else
+  fprintf(stdout, "Call not ok gmx_node_num\n");
   int i;
   (void) MPI_Comm_size(MPI_COMM_WORLD, &i);
   return i;
@@ -248,6 +410,7 @@ int gmx_node_rank(void)
 #ifndef GMX_MPI
   return 0;
 #else
+  fprintf(stdout, "Call not ok gmx_node_rank\n");
   int i;
   (void) MPI_Comm_rank(MPI_COMM_WORLD, &i);
   return i;
@@ -762,3 +925,43 @@ void gmx_finalize(void)
 #endif
 }
 
+void gmx_finalize_decaf(dca_decaf decaf)
+{
+#ifndef GMX_MPI
+  gmx_call("gmx_finalize");
+#else
+  int ret;
+
+  /* just as a check; we don't want to finalize twice */
+  int finalized;
+  MPI_Finalized(&finalized);
+  if (finalized)
+      return;
+
+  /* We sync the processes here to try to avoid problems
+   * with buggy MPI implementations that could cause
+   * unfinished processes to terminate.
+   */
+  MPI_Barrier(dca_get_com(decaf));
+
+  /*
+  if (DOMAINDECOMP(cr)) {
+    if (cr->npmenodes > 0 || cr->dd->bCartesian)
+      MPI_Comm_free(&cr->mpi_comm_mygroup);
+    if (cr->dd->bCartesian)
+      MPI_Comm_free(&cr->mpi_comm_mysim);
+  }
+  */
+
+  /* Apparently certain mpich implementations cause problems
+   * with MPI_Finalize. In that case comment out MPI_Finalize.
+   */
+  if (debug)
+    fprintf(debug,"Will call MPI_Finalize now\n");
+
+  ret = MPI_Finalize();
+  if (debug)
+    fprintf(debug,"Return code from MPI_Finalize = %d\n",ret);
+#endif
+}
+
diff --git a/src/kernel/md.c b/src/kernel/md.c
index 8ae0b4c..63313ef 100644
--- a/src/kernel/md.c
+++ b/src/kernel/md.c
@@ -99,6 +99,8 @@
 #include "corewrap.h"
 #endif
 
+#include <decaf/C/cdecaf.h>
+
 
 double do_md(FILE *fplog,t_commrec *cr,int nfile,const t_filenm fnm[],
              const output_env_t oenv, gmx_bool bVerbose,gmx_bool bCompact,
@@ -1303,6 +1305,53 @@ double do_md(FILE *fplog,t_commrec *cr,int nfile,const t_filenm fnm[],
             copy_mat(state->svir_prev,shake_vir);
             copy_mat(state->fvir_prev,force_vir);
         }
+
+        if(cr-> iteration % cr->stepDecaf == 0)
+        {
+            if(cr->terminated)
+                break; // Leaving the loop
+
+            bca_field field_pos = bca_create_arrayfield(state->x, bca_FLOAT,
+                                                        mdatoms->homenr * 3, 3,
+                                                        mdatoms->homenr * 3, false);
+
+            size_t i;
+            unsigned int *IDs = (unsigned int*)(malloc(mdatoms->homenr * sizeof(unsigned int)));
+            for (i = mdatoms->start; i < mdatoms->start + mdatoms->homenr; ++i)
+            {
+                if(cr->nnodes == 1)
+                    IDs[i] = i;
+                else
+                    IDs[i] = cr->dd->gatindex[i];
+            }
+            bca_field field_ID = bca_create_arrayfield(IDs, bca_UNSIGNED,
+                                                       mdatoms->homenr, 1,
+                                                       mdatoms->homenr, false);
+
+            bca_constructdata container = bca_create_constructdata();
+
+            if(!bca_append_field(container, "pos",
+                                 field_pos, bca_NOFLAG, bca_PRIVATE,
+                                 bca_SPLIT_DEFAULT, bca_MERGE_APPEND_VALUES))
+            {
+                gmx_fatal(FARGS, "Could not get append the data field in Decaf");
+            }
+            if(!bca_append_field(container, "ids",
+                                 field_ID, bca_NOFLAG, bca_PRIVATE,
+                                 bca_SPLIT_DEFAULT, bca_MERGE_APPEND_VALUES))
+            {
+                gmx_fatal(FARGS, "Could not get append the data field in Decaf");
+            }
+
+
+            dca_put(cr->decaf, container);
+
+            bca_free_field(field_pos);
+            bca_free_field(field_ID);
+            bca_free_constructdata(container);
+            free(IDs);
+            //fprintf(stdout, "Container sent\n");
+        }
         /*  ################## END TRAJECTORY OUTPUT ################ */
         
         /* Determine the wallclock run time up till now */
diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index 7b1b396..c974ab6 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -53,6 +53,10 @@
 #include "thread_mpi.h"
 #endif
 
+#define MAX_STRING_LENGTH 512
+
+#include <decaf/C/cdecaf.h>
+
 /* afm stuf */
 #include "pull.h"
 
@@ -507,8 +511,54 @@ int main(int argc,char *argv[])
   int      rc;
   char **multidir=NULL;
 
+  // Preparing Decaf before the initialization of Gromacs structures
+  char * prefix = getenv("DECAF_PREFIX");
+  if(prefix == NULL)
+  {
+      fprintf(stderr, "ERROR: environment variable DECAF_PREFIX not defined. "
+              "Please export DECAF_PREFIX to point to the root of your decaf "
+              "install directory.\n");
+      exit(1);
+  }
 
-  cr = init_par(&argc,&argv);
+  char libpath[MAX_STRING_LENGTH];
+  char path[MAX_STRING_LENGTH];
+  strcpy(libpath, "/examples/gromacs/libmod_dflow_gromacs.so");
+  strcpy(path, prefix);
+  strcat(path, libpath);
+
+  MPI_Init(&argc, &argv);
+  dca_decaf decaf = dca_create_decaf(MPI_COMM_WORLD);
+  fprintf(stdout,"Creation of Decaf completed\n");
+
+  dca_init_from_json(decaf, "wflow_gromacs.json");
+  if(decaf == NULL)
+      fprintf(stdout, "ERROR : fail to intialize decaf.\n");
+  else
+      fprintf(stdout, "Initialization of Decaf successfull\n");
+
+  if(dca_my_node(decaf, "gmx"))
+      fprintf(stdout,"Launching gmx\n");
+  else //dflow case
+  {
+      fprintf(stdout, "Cleaning for the dflow\n");
+      //MPI_Barrier(MPI_COMM_WORLD);
+      fprintf(stdout, "Barrier passed.\n");
+      dca_terminate(decaf);
+      MPI_Finalize();
+      dca_free_decaf(decaf);
+      exit(0);
+  }
+
+  cr = init_par_decaf(&argc, &argv, decaf);
+  cr->forceIds = NULL;    // Ids of atoms to steer
+  cr->nbIds = 0;
+  cr->force = NULL;       // force vector to apply
+  cr->stepDecaf = 100;    // Do a get/put every stepDecaf iteration
+  cr->firstStep = true;   // Marker to signal the first time we call Decaf.
+                          // Needed not to do a get on the first iteration.
+  cr->iteration = 0;      // step in the simulation loop
+  cr->terminated = false;
 
   if (MASTER(cr))
     CopyRight(stderr, argv[0]);
@@ -670,8 +720,13 @@ int main(int argc,char *argv[])
                 nstepout,resetstep,nmultisim,repl_ex_nst,repl_ex_seed,
                 pforce, cpt_period,max_hours,deviceOptions,Flags);
 
-  if (gmx_parallel_env_initialized())
-      gmx_finalize();
+  dca_terminate(cr->decaf);
+  fprintf(stdout," Decaf terminated\n");
+  gmx_finalize_decaf(cr->decaf);
+
+  dca_free_decaf(decaf);
+
+  MPI_Finalize();
 
   if (MULTIMASTER(cr)) {
       thanx(stderr);
diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index 60ef80e..edccc3c 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -96,6 +96,105 @@
 
 #include "qmmm.h"
 
+#include <gmx_ga2la.h>
+
+void steer_from_decaf(t_commrec *cr, rvec *forces)
+{
+    // We don't do a get ont he first iteration to avoid deadlock
+    if(cr->firstStep)
+    {
+        fprintf(stderr, "First iteration, we don't do anything\n");
+        cr->firstStep = false;
+        cr->iteration += 1;
+        return;
+    }
+
+    if(cr->iteration % cr->stepDecaf == 0)
+    {
+        //Getting the information from the Graph
+        unsigned int nb_data = 0;
+        bca_constructdata* in_data = dca_get(cr->decaf, &nb_data);
+        if(in_data == NULL || nb_data == 0)
+        {
+            fprintf(stderr, "Steering is not connected\n");
+            cr->terminated = true;
+            return; // No steering available
+        }
+
+        bca_field fieldForce = bca_get_arrayfield(in_data[0], "force", bca_FLOAT);
+
+        if(!fieldForce)
+        {
+            fprintf(stderr, "Error: the field \'force\' is not present in the data model. Abording\n");
+            MPI_Abort(MPI_COMM_WORLD, 0);
+        }
+
+        size_t size;
+        float* arrayForce = bca_get_array(fieldForce, bca_FLOAT, &size);
+
+        //We copy the force so we can apply it when not in a decaf iteration
+        if( cr->force == NULL )
+            cr->force = (float*)malloc(size * sizeof(float));
+        memcpy(cr->force, arrayForce, size * sizeof(float));
+
+        if(!cr->forceIds) //We have not received the IDs yet
+        {
+            bca_field fieldIds = bca_get_arrayfield(in_data[0], "ids", bca_INT);
+            if(!fieldIds)
+            {
+                fprintf(stderr, "Error: the field \'ids\' is not present in the data model. Abording\n");
+                MPI_Abort(MPI_COMM_WORLD, 0);
+            }
+
+            // Saving the Ids that we will use at each iteration
+            size_t size;
+            float* arrayIds = bca_get_array(fieldIds, bca_INT, &size);
+            cr->forceIds = (int*)malloc(size * sizeof(int));
+            cr->nbIds = size;
+            memcpy(cr->forceIds, arrayIds, size * sizeof(int));
+
+            bca_free_field(fieldIds);
+
+        }
+
+
+        bca_free_field(fieldForce);
+        bca_free_constructdata(in_data[0]);
+
+    }
+
+    // Appying the forces if we have everything required
+    if(cr->force && cr->forceIds)
+    {
+        int i;
+        for(i = 0; i < cr->nbIds; i++)
+        {
+            int index = cr->forceIds[i];
+            int local_index = -1;
+            int cell_id = -1;
+            if(cr->dd == NULL) // No domain decomposition, 1 MPI rank
+            {
+                cell_id = 0;
+                local_index = index;
+            }
+            else if( ga2la_get_home(cr->dd->ga2la, index, &local_index) )
+                cell_id = 0;
+
+            if(0==cell_id) //The particule is treated by the current node
+            {
+                float fx = 1000.0 * cr->force[0];
+                float fy = 1000.0 * cr->force[1];
+                float fz = 1000.0 * cr->force[2];
+
+                forces[local_index][0] += fx;
+                forces[local_index][1] += fy;
+                forces[local_index][2] += fz;
+            }
+        }
+    }
+    cr->iteration += 1;
+}
+
 #if 0
 typedef struct gmx_timeprint {
     
@@ -755,6 +854,8 @@ void do_force(FILE *fplog,t_commrec *cr,
                       start,homenr,mdatoms->chargeA,x,fr->f_novirsum,
                       inputrec->ex,inputrec->et,t);
         }
+
+        steer_from_decaf(cr, f);
         
         /* Communicate the forces */
         if (PAR(cr))
-- 
2.1.4


From 05d83d33a65f5f4d27f4c19c54738e11b6aaf3e4 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Thu, 25 Aug 2016 18:12:00 -0500
Subject: [PATCH 2/9] Fix the double MPI_Init

---
 src/gmxlib/network.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 252bf44..9cd986f 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -250,7 +250,7 @@ int gmx_setup_decaf(int *argc,char **argv,int *nnodes, dca_decaf decaf)
 #ifdef GMX_FAHCORE
   (void) fah_MPI_Init(argc,&argv);
 #else
-  (void) MPI_Init(argc,&argv);
+  //(void) MPI_Init(argc,&argv);
 #endif
 #endif
   (void) MPI_Comm_size( dca_get_com(decaf), &mpi_num_nodes );
-- 
2.1.4


From 6106361ba816e1b706fb4c4bae4202574f239e46 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 10:37:24 -0500
Subject: [PATCH 3/9] Fix data type

---
 src/mdlib/sim_util.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index edccc3c..455a319 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -148,7 +148,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
 
             // Saving the Ids that we will use at each iteration
             size_t size;
-            float* arrayIds = bca_get_array(fieldIds, bca_INT, &size);
+            int* arrayIds = bca_get_array(fieldIds, bca_INT, &size);
             cr->forceIds = (int*)malloc(size * sizeof(int));
             cr->nbIds = size;
             memcpy(cr->forceIds, arrayIds, size * sizeof(int));
-- 
2.1.4


From d199667645a0052c4691aa8eac5d999bc2352e74 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 10:56:26 -0500
Subject: [PATCH 4/9] Add debug message

---
 src/mdlib/sim_util.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index 455a319..f4178de 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -111,6 +111,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
 
     if(cr->iteration % cr->stepDecaf == 0)
     {
+        fprintf(stderr, "Receiving data...\n");
         //Getting the information from the Graph
         unsigned int nb_data = 0;
         bca_constructdata* in_data = dca_get(cr->decaf, &nb_data);
@@ -121,6 +122,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
             return; // No steering available
         }
 
+        fprintf(stderr,"Retrieving the force field\n");
         bca_field fieldForce = bca_get_arrayfield(in_data[0], "force", bca_FLOAT);
 
         if(!fieldForce)
@@ -132,13 +134,18 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
         size_t size;
         float* arrayForce = bca_get_array(fieldForce, bca_FLOAT, &size);
 
+        fprintf(stderr, "Reception of the array force of size %zu\n", size);
+
         //We copy the force so we can apply it when not in a decaf iteration
         if( cr->force == NULL )
             cr->force = (float*)malloc(size * sizeof(float));
         memcpy(cr->force, arrayForce, size * sizeof(float));
 
+        fprintf(stderr, "Copy of the force in local buffer done\n");
+
         if(!cr->forceIds) //We have not received the IDs yet
         {
+            fprintf(stderr, "Reception of the buffer of IDs\n");
             bca_field fieldIds = bca_get_arrayfield(in_data[0], "ids", bca_INT);
             if(!fieldIds)
             {
@@ -149,6 +156,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
             // Saving the Ids that we will use at each iteration
             size_t size;
             int* arrayIds = bca_get_array(fieldIds, bca_INT, &size);
+            fprintf(stderr, "Rception of a force filter of size %zu\n", size);
             cr->forceIds = (int*)malloc(size * sizeof(int));
             cr->nbIds = size;
             memcpy(cr->forceIds, arrayIds, size * sizeof(int));
@@ -166,6 +174,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
     // Appying the forces if we have everything required
     if(cr->force && cr->forceIds)
     {
+        fprintf(stderr, "Applying force at iteration %i\n", cr->iteration);
         int i;
         for(i = 0; i < cr->nbIds; i++)
         {
@@ -191,6 +200,7 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
                 forces[local_index][2] += fz;
             }
         }
+        fprintf(stderr, "Force applied for iteration %i\n", cr->iteration);
     }
     cr->iteration += 1;
 }
-- 
2.1.4


From f54a92f3cbb6058fc4db49352255121233a1fbb6 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 11:01:24 -0500
Subject: [PATCH 5/9] Not apply forces

---
 src/mdlib/sim_util.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index f4178de..50bb15d 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -195,9 +195,9 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
                 float fy = 1000.0 * cr->force[1];
                 float fz = 1000.0 * cr->force[2];
 
-                forces[local_index][0] += fx;
-                forces[local_index][1] += fy;
-                forces[local_index][2] += fz;
+                //forces[local_index][0] += fx;
+                //forces[local_index][1] += fy;
+                //forces[local_index][2] += fz;
             }
         }
         fprintf(stderr, "Force applied for iteration %i\n", cr->iteration);
-- 
2.1.4


From 53ac9a08766456e0e3acb6f95e3dd69a8d4c4cf0 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 11:12:30 -0500
Subject: [PATCH 6/9] apply forces

---
 src/mdlib/sim_util.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index 50bb15d..f4178de 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -195,9 +195,9 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
                 float fy = 1000.0 * cr->force[1];
                 float fz = 1000.0 * cr->force[2];
 
-                //forces[local_index][0] += fx;
-                //forces[local_index][1] += fy;
-                //forces[local_index][2] += fz;
+                forces[local_index][0] += fx;
+                forces[local_index][1] += fy;
+                forces[local_index][2] += fz;
             }
         }
         fprintf(stderr, "Force applied for iteration %i\n", cr->iteration);
-- 
2.1.4


From 02deacb994cbd49e73d41c3e31ce3b54fe4eaa7d Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 11:18:09 -0500
Subject: [PATCH 7/9] Remove debug messages

---
 src/mdlib/sim_util.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/src/mdlib/sim_util.c b/src/mdlib/sim_util.c
index f4178de..455a319 100644
--- a/src/mdlib/sim_util.c
+++ b/src/mdlib/sim_util.c
@@ -111,7 +111,6 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
 
     if(cr->iteration % cr->stepDecaf == 0)
     {
-        fprintf(stderr, "Receiving data...\n");
         //Getting the information from the Graph
         unsigned int nb_data = 0;
         bca_constructdata* in_data = dca_get(cr->decaf, &nb_data);
@@ -122,7 +121,6 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
             return; // No steering available
         }
 
-        fprintf(stderr,"Retrieving the force field\n");
         bca_field fieldForce = bca_get_arrayfield(in_data[0], "force", bca_FLOAT);
 
         if(!fieldForce)
@@ -134,18 +132,13 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
         size_t size;
         float* arrayForce = bca_get_array(fieldForce, bca_FLOAT, &size);
 
-        fprintf(stderr, "Reception of the array force of size %zu\n", size);
-
         //We copy the force so we can apply it when not in a decaf iteration
         if( cr->force == NULL )
             cr->force = (float*)malloc(size * sizeof(float));
         memcpy(cr->force, arrayForce, size * sizeof(float));
 
-        fprintf(stderr, "Copy of the force in local buffer done\n");
-
         if(!cr->forceIds) //We have not received the IDs yet
         {
-            fprintf(stderr, "Reception of the buffer of IDs\n");
             bca_field fieldIds = bca_get_arrayfield(in_data[0], "ids", bca_INT);
             if(!fieldIds)
             {
@@ -156,7 +149,6 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
             // Saving the Ids that we will use at each iteration
             size_t size;
             int* arrayIds = bca_get_array(fieldIds, bca_INT, &size);
-            fprintf(stderr, "Rception of a force filter of size %zu\n", size);
             cr->forceIds = (int*)malloc(size * sizeof(int));
             cr->nbIds = size;
             memcpy(cr->forceIds, arrayIds, size * sizeof(int));
@@ -174,7 +166,6 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
     // Appying the forces if we have everything required
     if(cr->force && cr->forceIds)
     {
-        fprintf(stderr, "Applying force at iteration %i\n", cr->iteration);
         int i;
         for(i = 0; i < cr->nbIds; i++)
         {
@@ -200,7 +191,6 @@ void steer_from_decaf(t_commrec *cr, rvec *forces)
                 forces[local_index][2] += fz;
             }
         }
-        fprintf(stderr, "Force applied for iteration %i\n", cr->iteration);
     }
     cr->iteration += 1;
 }
-- 
2.1.4


From b621eaf1cf4ac4647f9ea7596d893ffd63531483 Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Mon, 29 Aug 2016 13:00:42 -0500
Subject: [PATCH 8/9] Add the option of the decaf steps

---
 src/kernel/mdrun.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/kernel/mdrun.c b/src/kernel/mdrun.c
index c974ab6..33034aa 100644
--- a/src/kernel/mdrun.c
+++ b/src/kernel/mdrun.c
@@ -408,6 +408,7 @@ int main(int argc,char *argv[])
   int  nstepout=100;
   int  nthreads=0; /* set to determine # of threads automatically */
   int  resetstep=-1;
+  int  nstepdecaf=10;
   
   rvec realddxyz={0,0,0};
   const char *ddno_opt[ddnoNR+1] =
@@ -435,6 +436,8 @@ int main(int argc,char *argv[])
 #endif
     { "-npme",    FALSE, etINT, {&npme},
       "Number of separate nodes to be used for PME, -1 is guess" },
+    { "-nstepdecaf",    FALSE, etINT, {&nstepdecaf},
+      "Output decaf data everu nstepdecaf iteration" },
     { "-ddorder", FALSE, etENUM, {ddno_opt},
       "DD node order" },
     { "-ddcheck", FALSE, etBOOL, {&bDDBondCheck},
@@ -554,7 +557,7 @@ int main(int argc,char *argv[])
   cr->forceIds = NULL;    // Ids of atoms to steer
   cr->nbIds = 0;
   cr->force = NULL;       // force vector to apply
-  cr->stepDecaf = 100;    // Do a get/put every stepDecaf iteration
+  cr->stepDecaf = nstepdecaf;    // Do a get/put every stepDecaf iteration
   cr->firstStep = true;   // Marker to signal the first time we call Decaf.
                           // Needed not to do a get on the first iteration.
   cr->iteration = 0;      // step in the simulation loop
-- 
2.1.4


From 664b4e6b622242fff03eeaf159cef4ef8d0138bb Mon Sep 17 00:00:00 2001
From: Matthieu Dreher <mdreher@anl.gov>
Date: Wed, 31 Aug 2016 13:42:46 -0500
Subject: [PATCH 9/9] Remove the MPI_Finalized from Gromacs and replace it in
 mdrun instead

---
 src/gmxlib/network.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gmxlib/network.c b/src/gmxlib/network.c
index 9cd986f..f536fdd 100644
--- a/src/gmxlib/network.c
+++ b/src/gmxlib/network.c
@@ -959,7 +959,7 @@ void gmx_finalize_decaf(dca_decaf decaf)
   if (debug)
     fprintf(debug,"Will call MPI_Finalize now\n");
 
-  ret = MPI_Finalize();
+  //ret = MPI_Finalize();
   if (debug)
     fprintf(debug,"Return code from MPI_Finalize = %d\n",ret);
 #endif
-- 
2.1.4

